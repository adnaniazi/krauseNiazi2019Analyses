---
title: "Krause/Niazi et al. RNA Data Analysis"
author: "Adnan M. Niazi & Maximillian Krause"
date: "5/13/2019"
output:
  html_document: default
  pdf_document: default
---

This document contains all the analyses done on data that we generated for the tailfindr paper. Knit this document after you have successfully run `drake::r_make()`.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Load the required libraries first:
```{r load_libraries}
pacman::p_load(dplyr, magrittr, ggplot2, drake, knitr, ggpubr, here, tidyverse)
```

```{r echo=FALSE, warning=FALSE}
# source scripts for plotting
source(here('scripts', 'figures', 'geom_two_sided_flat_violin.R'))
source(here('scripts', 'figures', 'geom_one_sided_flat_violin.R'))
```

Now load the data:
```{r load-libraries}
loadd(rna_kr_data)
```

## About the data
`rna_kr_data` is made automatically when `drake::r_make()` command is run. It is a dataframe containing RNA data from three replicates of Oxford Nanopore Direct RNA sequencing experiments. The first two replicates were obtained using RNA-SQK001 kit with reverse transcription, while the third replicate was obtained using RNA-SQK002 sequencing kit and omitting the reverse transcription step during library preparation. 

For each read, `rna_kr_data` dataframe contains:

1. Output of tailfindr

2. Output of Nanopolish 

3. Barcode label of the read, and

4. Location of the poly(A) end adjacent to eGFP transcript found by alignment of the expected eGFP sequence.

The raw CSV files from which `rna_kr_data` was made are present in the `extdata/` directory. The code used to consolidate all these disparate pieces of information into a single data frame (`rna_kr_data`) is present in the `Analyses/` and `R/` directories.

Here is a description of columns:
```{r data-description-1, echo=FALSE}
col_names_df <- data.frame(Columns = c("read_id", "barcode", "replicate", "file_path", "tail_start_tf", "tail_end_tf", "samples_per_nt_tf", "tail_length_tf", "tail_start_np", "tail_end_np", "read_rate_np", "tail_length_np", "qc_tag_np", "samples_per_nt_np","transcript_alignment_start","kit"), Description = c("Unique read ID generated by MinKNOW",
"Barcode assigning the expected poly(A) tail length", "Replicate number", "Full file path (not relevant)", "tailfindr's estimate of poly(A) start site",  "tailfindr's estimate of poly(A) end site",
"tailfindr's estimate of read-specific nucleotide translocation rate (samples per nucleotide)",  "tailfindr's estimate of poly(A) tail length",  "Nanopolish estimate of poly(A) start site", "Nanopolish estimate of poly(A) end site", "Nanopolish read rate", "Nanopolish estimate of poly(A) tail length", "Nanopolish QC tag", "Nanopolish estimate of read-specific nucleotide translocation rate (samples per nucleotide) calculated by 3012/read_rate", "Location of poly(A) end as detected by eGFP sequence alignment", 'ONT Library prep kit used'))
```
```{r data-description-2}
knitr::kable(col_names_df)
```

## 1. Comparing ONT Library prep conditions: SQK-RNA001 vs. SQK-RNA002
Create a dataset in which tail lengths are capped to 300 nt.
```{r echo=TRUE}
rna_kr_data_capped <- rna_kr_data %>% 
  dplyr::mutate(tail_length_tf = ifelse(tail_length_tf >= 300, 300, tail_length_tf),
                tail_length_np = ifelse(tail_length_np >= 300, 300, tail_length_np))
```

### Tail length densities
```{r, warning=FALSE}
p <- ggplot(data = rna_kr_data_capped, aes(x = barcode, y = tail_length_tf, 
                                           color = kit, fill = kit)) +
  geom_two_sided_flat_violin(position = position_nudge(x = .2, y = 0), alpha = .5) +
  facet_grid(~barcode, scales = 'free') +
  geom_hline(aes(yintercept=as.numeric(as.character(barcode)))) 
```
```{r, warning=FALSE, echo=FALSE}
lengend_name <- 'Library prep kit'
legend_labels <- c('SQK-RNA001 +RT', 
                   'SQK-RNA002 -RT')
p <- p + theme(panel.background = element_blank(),
        panel.grid.minor = ggplot2::element_line(colour="grey", size=0.5),
        panel.grid.major = ggplot2::element_line(colour="grey", size=0.5),
        panel.grid.major.x = element_blank(),
        axis.title.x = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        legend.direction = "horizontal",
        legend.position = "top") +
  scale_color_brewer(palette = "Paired", name = lengend_name, labels = legend_labels) +
  scale_fill_brewer(palette = "Paired", name = lengend_name, labels = legend_labels) +
  scale_y_continuous(minor_breaks = seq(0, 300, 25)) +
  ylab('tailfindr tail length [nt]') +
  labs(caption = 'tailfindr tail length estimate is indepedent of sequencing kit used 
       and whether or not reverse transcription step was performed. 
       The black horizontal lines represent the expected poly(A) tail length.')
p
```

### Tail length statistics
```{r, warning=FALSE}
# define the function for computing standard error 
std_err <- function(x) sd(x, na.rm = TRUE)/sqrt(length(x))

# summarize the data and display a table
summary_data <- rna_kr_data %>% group_by(barcode, kit) %>% 
  summarise(read_count = n(),
            mean = mean(tail_length_tf, na.rm = TRUE),
            median = median(tail_length_tf, na.rm = TRUE),
            std_dev = sd(tail_length_tf, na.rm = TRUE),
            std_err = std_err(tail_length_tf)) 
summary_data %<>% mutate(cof_var = std_dev/mean)
kable(summary_data)
```


## 2. Comparing technical replicates: Replicate 1 vs Replicate 2 (both RNA001)
The first two replicates (both obtained with SQK-RNA001) are loaded from complete dataset.
```{r, warning=FALSE}
rna001_data <- rna_kr_data_capped %>% filter(replicate == 1 | replicate == 2)
```

### Tail length densities
```{r, warning=FALSE}
p <- ggplot(rna001_data, aes(x = barcode, y = tail_length_tf, 
                             color = replicate, fill = replicate)) +
  geom_two_sided_flat_violin(position = position_nudge(x = 0, y = 0), alpha = .5) +
  facet_grid(~barcode, scales = 'free') +
  geom_hline(aes(yintercept = as.numeric(as.character(barcode)))) 
```
```{r, warning=FALSE, echo=FALSE}
lengend_name <- 'Replicate'
legend_labels <- c('Replicate 1', 
                   'Replicate 2')
p <- p + theme(panel.background = element_blank(),
        panel.grid.minor = ggplot2::element_line(colour="grey", size=0.5),
        panel.grid.major = ggplot2::element_line(colour="grey", size=0.5),
        panel.grid.major.x = element_blank(),
        axis.title.x = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        legend.direction = "horizontal",
        legend.position = "top") +
  scale_color_brewer(palette = "Paired", name = lengend_name, labels = legend_labels) +
  scale_fill_brewer(palette = "Paired", name = lengend_name, labels = legend_labels) +
  ggplot2::scale_y_continuous(minor_breaks = seq(0, 300, 25)) +
  ylab('tailfindr tail length [nt]') +
  labs(caption = 'tailfindr tail length estimate is robust across technical replicates.
       The black horizontal lines represent the expected poly(A) tail length.',
       fill = 'Replicate')
p
```

### Tail length summaries

```{r, warning=FALSE}
summary_data <- rna001_data %>% group_by(barcode, replicate) %>% 
  summarise(read_count = n(),
            mean = mean(tail_length_tf, na.rm = TRUE),
            median = median(tail_length_tf, na.rm = TRUE),
            std_dev = sd(tail_length_tf, na.rm = TRUE),
            std_err = std_err(tail_length_tf)) 
summary_data %<>% mutate(cof_var = std_dev/mean)
kable(summary_data)
```


## 3. tailfindr poly(A) end vs. sequence end by alignment of eGFP
To test whether poly(A) end as defined by tailfindr and the sequence end of eGFP as defined by sequence alignment match, a scatter plot is generated:
```{r, warning=FALSE}
p <- ggplot(rna_kr_data, aes(x = tail_end_tf, y = transcript_alignment_start)) +
    geom_point(shape = 21, colour = 'black', fill = 'black', 
               size = 2, stroke=0, alpha = 0.1) +
    geom_abline(intercept = 0, slope = 1, color="red", 
                linetype = 'dotted', size = 0.7) +
    geom_smooth(method = 'lm', formula = y~x, 
                color="#797979", fullrange = TRUE, se = FALSE, size = 0.5) +
    stat_cor(method = "pearson", label.x = 5000, label.y = 30000) +
    coord_cartesian(xlim = c(0, 40000), ylim = c(0, 40000))
```

```{r, warning=FALSE, echo=FALSE}
p <- p + theme_bw() +
  theme(
    axis.line =element_line(colour = "black"),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank()
  ) +
  xlab('tailfindr tail end') +
  ylab('Tail end defined eGFP alignment') + 
  labs(caption = 'The red dotted line represents x = y.
       The grey line represents the linear model fit.')
p
```

To better visualize the precision of end definition, a histogram of the difference between tailfindr poly(A) end and the sequence alignment position is generated:
```{r, warning=FALSE}
data <- mutate(rna_kr_data, diff = tail_end_tf - transcript_alignment_start)
p <- ggplot(data, aes(x = diff)) + 
  geom_histogram(binwidth = 1)
```

```{r, warning=FALSE, echo=TRUE}
p <- p +
  theme_bw() +
  coord_cartesian(xlim = c(-500, 500)) +
  scale_x_continuous(minor_breaks = seq(-500, 500, 50)) +
  xlab('tailfindr tail end - sequence end defined by eGFP alignment') +
  ylab('Read count')
p
```

## 4. Nanopolish tail start estimate vs. tailfindr tail start estimate
Let us generate a scatter plot of tailfindr and Nanopolish poly(A) tail start estimates:

```{r, warning=FALSE}
p <- ggplot(rna_kr_data, aes(x = tail_start_tf, y = tail_start_np)) +
    geom_point(shape = 21, colour = 'black', fill = 'black', 
               size = 2, stroke = 0, alpha = 0.1) +
    geom_abline(intercept = 0, slope = 1, color="red", 
                linetype = 'dotted', size = 0.7) +
    geom_smooth(method = 'lm', formula = y~x, 
                color="#797979", fullrange = TRUE, se = FALSE, size = 0.5) +
    stat_cor(method = "pearson", label.x = 5000, label.y = 30000) +
    coord_cartesian(xlim = c(0, 40000), ylim = c(0, 40000))
```

```{r, warning=FALSE, echo=FALSE}
p <- p + theme_bw() +
  theme(
    axis.line = element_line(colour = "black"),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank()
  ) +
  xlab('tailfindr tail start') +
  ylab('Nanopolish tail start') + 
  labs(caption = 'The red dotted line represents x = y.
       The grey line represents the linear model fit.')
p
```


To better visualize the overlap in poly(A) start detection, a histogram of the difference between Nanopolish and tailfindr poly(A) start is generated:
```{r, warning=FALSE}
data <- mutate(rna_kr_data, diff = tail_start_np - tail_start_tf)
p <- ggplot(data, aes(x = diff)) + 
  geom_histogram(binwidth = 1) + 
  theme_bw() + 
  coord_cartesian(xlim = c(-500, 500)) +
  scale_x_continuous(minor_breaks = seq(-500, 500, 50)) +
  xlab('Nanopolish tail start - tailfindr tail start') +
  ylab('Read count')
p
```

## 5. Nanopolish tail end estimate vs. tailfindr tail end estimate
Let us generate a scatter plot of tailfindr and Nanopolish poly(A) tail end estimates:

```{r, warning=FALSE}
p <- ggplot(rna_kr_data, aes(x = tail_end_tf, y = tail_end_np)) +
    geom_point(shape = 21, colour = 'black', fill = 'black', 
               size = 2, stroke = 0, alpha = 0.1) +
    geom_abline(intercept = 0, slope = 1, color="red", 
                linetype = 'dotted', size = 0.7) +
    geom_smooth(method = 'lm', formula = y~x, 
                color="#797979", fullrange = TRUE, se = FALSE, size = 0.5) +
    stat_cor(method = "pearson", label.x = 5000, label.y = 30000) +
    coord_cartesian(xlim = c(0, 40000), ylim = c(0, 40000))
```

```{r, warning=FALSE, echo=FALSE}
p <- p + theme_bw() +
  theme(
    axis.line = element_line(colour = "black"),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank()
  ) +
  xlab('tailfindr tail end') +
  ylab('Nanopolish tail end') + 
  labs(caption = 'The red dotted line represents x = y.
       The grey line represents the linear model fit.')
p
```


To better visualize the overlap in poly(A) end detection, a histogram of the difference between Nanopolish and tailfindr poly(A) end is generated:
```{r, warning=FALSE}
data <- mutate(rna_kr_data, diff = tail_end_np - tail_end_tf)
p <- ggplot(data, aes(x = diff)) + 
  geom_histogram(binwidth = 1) + 
  theme_bw() + 
  coord_cartesian(xlim = c(-500, 500)) +
  scale_x_continuous(minor_breaks = seq(-500, 500, 50)) +
  xlab('Nanopolish tail end - tailfindr tail end') +
  ylab('Read count')
p
```

